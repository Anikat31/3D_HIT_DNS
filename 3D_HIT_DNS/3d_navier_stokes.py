# -*- coding: utf-8 -*-
"""3D_Navier_Stokes.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/17lYSJjpbkhqtnqiby39PXBUy4QTwoPuN
"""


###############################################################################
'''
Importing Libraries
'''
###############################################################################

import jax.numpy as jnp
from jax import jit ,lax
from jax import random

from jax import config
config.update("jax_enable_x64", True)

key = random.PRNGKey(42)

import numpy as np

import matplotlib.pyplot as plt


import warnings
warnings.filterwarnings("ignore")

import seaborn as sns

from tqdm import tqdm

import jax

gpu_info = !nvidia-smi
gpu_info = '\n'.join(gpu_info)
if gpu_info.find('failed') >= 0:
  print('Not connected to a GPU')
else:
  print(gpu_info)

fft = jnp.fft.rfftn
ifft = jnp.fft.irfftn

####################################################################################
'''
General definations and set-up
'''
####################################################################################
pi = np.pi

nu = 5e-3
# Size of the system

N = 2**5

Nf = int(N/2 + 1)

# tri-length of model
L = 2*pi

mesh = jnp.linspace(0, L, N, endpoint= False)

dx = mesh[1]-mesh[0]

X ,Y, Z = jnp.meshgrid(mesh,mesh,mesh,indexing = 'ij')

#Time step defination
dt = 5e-3

####################################################################################
'''
General definations and set-up for the spectral space
'''
####################################################################################

# The Fourier variables
kx , ky , kz  = jnp.meshgrid(jnp.fft.fftfreq(N, dx)*(2*pi),jnp.fft.fftfreq(N, dx)*(2*pi), jnp.fft.rfftfreq(N, dx)*(2*pi),indexing= 'ij')

k = jnp.stack([kx,ky,kz])

k2 = (k[0]**2 + k[1]**2 + k[2]**2)

sqrt_k2 = jnp.sqrt(k2)


####################################################################################
'''
Cut-off and Mask for Spectral method
'''
####################################################################################

alias_mask = jnp.where(np.round(sqrt_k2) <= N//3, 1, 0)

# alias_mask = (abs(k[0])<N//3)*(abs(k[1])<N//3)*(abs(k[2])<N//3)

k = k*alias_mask

k2 = k2*alias_mask

k_over_k2 = jnp.where(k2 == 0 , 0 ,  k/k2)*alias_mask

sqrt_k2 = alias_mask*sqrt_k2

shells = np.arange(-0.5, N//2 + 1 , 1.)
shells[0] = 0.


kvals = np.arange(0,N//2+1)

term_norm = 1/N**6
normalize = np.where( (k[2] == 0) + (k[2] == N//2) , term_norm ,2*term_norm)

plt.imshow(jnp.fft.fftshift(1*alias_mask[:,:,7].T,1), origin = 'lower')
plt.colorbar()

def e3d_to_e1d(x):
  return np.histogram(sqrt_k2.ravel(),bins = shells,weights = x.ravel())[0]

@jit
def cross_func(a, b):

    return fft(jnp.stack([
        a[1]*b[2] - a[2]*b[1],
        a[2]*b[0] - a[0]*b[2],
        a[0]*b[1] - a[1]*b[0]]), axes=(1,2,3))



@jit
def curl_func(a, k = k ):

    return  ifft(jnp.stack([
        1j * (k[1] * a[2] - k[2] * a[1]),
        1j * (k[2] * a[0] - k[0] * a[2]),
        1j * (k[0] * a[1] - k[1] * a[0]) ]),axes=(1,2,3))

@jit
def RK4(U_hat):

  K1 = computeRHS(U_hat)
  K2 = computeRHS(U_hat + 0.5 * dt * K1)
  K3 = computeRHS(U_hat + 0.5 * dt * K2)
  K4 = computeRHS(U_hat + dt * K3)

  return U_hat + (dt / 6) * (K1 + 2*( K2 +  K3 )+ K4)

def dot(A):

  return (1j*(k[0]*A[0] + k[1]*A[1] + k[2]*A[2]))

@jit
def computeRHS(U_dumm):

  nonlinear_term = alias_mask*cross_func(ifft(U_dumm, axes=(1, 2, 3)), curl_func(U_dumm))

  return alias_mask*(nonlinear_term - jnp.einsum('ijkl,ijkl->jkl', nonlinear_term, k_over_k2)* k - nu * k2 * U_dumm)

@jit
def enstrophy(u_hat, kx = k[0], ky = k[1], kz = k[2]):

    omega_hat_sq = (
        jnp.abs(1j * (ky * u_hat[2] - kz * u_hat[1]))**2 +
        jnp.abs(1j * (kz * u_hat[0] - kx * u_hat[2]))**2 +
        jnp.abs(1j * (kx * u_hat[1] - ky * u_hat[0]))**2
    )

    return 0.5 * jnp.sum(omega_hat_sq)

U = jnp.stack([jnp.sin(Y)*jnp.cos(X)*jnp.sin(Z),jnp.sin(X)*jnp.cos(Y) * jnp.sin(Z) ,-2*jnp.cos(Z)*jnp.sin(X)*jnp.sin(Y)])

# U = jnp.stack([jnp.cos(Y) + jnp.sin(Z),jnp.cos(Z) + jnp.sin(X) ,jnp.cos(X) + jnp.sin(Y)])

U_hat =  fft(U, axes=(1,2,3))

plt.imshow( ifft(U_hat[0])[-9,:,:].real, cmap = 'inferno', origin = 'lower')
plt.colorbar()

Commented out IPython magic to ensure Python compatibility.


steps = 2000
E = np.zeros(int(steps))
w_k = np.zeros(int(steps))

for i in tqdm(range(steps)):

  U_hat = RK4(U_hat)
  ek = normalize*0.5*(jnp.abs(U_hat[0])**2 + jnp.abs(U_hat[1])**2 + jnp.abs(U_hat[2])**2)
  E[i] = jnp.sum(ek)
  w_k[i] = jnp.sum(jnp.arange(N//2 + 1)**2*e3d_to_e1d(ek))

U_real = jnp.fft.irfftn(U_hat, axes=(1, 2, 3))
np.savez_compressed('u_5', U = U_real )

plt.imshow( ifft(U_hat[0])[0,:,:]  , origin = 'lower', cmap = 'inferno')
plt.colorbar()

div_v = np.sum(U_hat*1j*k, axis = 0)
plt.imshow(ifft(div_v)[1], cmap = 'inferno')
plt.colorbar()



kvals = np.arange(0,N//2)

ek = normalize*0.5*(np.abs(U_hat[0])**2 + np.abs(U_hat[1])**2 + np.abs(U_hat[2])**2) #! This is the 3D ek array
E_k = e3d_to_e1d(ek)


plt.loglog(kvals[2:N//3+2],E_k[2:N//3+2]/E_k[4],'o-')

plt.loglog(kvals[2:N//3+2],EE[2:N//3+2]/EE[4],'o-')


a_anikat = np.linspace(0,10,2000)
a_raj = np.linspace(0,10,200)
plt.plot(a_anikat,1*w_k/w_k[-1], '.', ms = 1 )

plt.plot(a_raj,W[1:]/W[-1], '.', ms = 1 )

plt.plot(E)

shells= jnp.arange(-0.5,N//2+1 + 1,1)

k_whole  = jnp.stack(jnp.meshgrid(jnp.fft.fftfreq(N, dx)*(2*pi),jnp.fft.fftfreq(N, dx)*(2*pi), jnp.fft.fftfreq(N, dx)*(2*pi),indexing= 'ij'))

k2_whole = (k_whole[0]**2 + k_whole[1]**2 + k_whole[2]**2)

sqrt_k2_whole = jnp.sqrt(k2_whole)

def compute_energy_transfer(u_hat,K_min,K_max , Q_min, Q_max ,sqrt_k2 = sqrt_k2_whole,k_whole = k_whole, shells = shells):

  u = jnp.fft.irfftn(u_hat, axes=(1, 2, 3))

  u_hat = jnp.fft.fftn(u, axes=(1, 2, 3))

  mask_K = np.where((sqrt_k2_whole >= K_min),1 ,0)*np.where((sqrt_k2_whole <= K_max) ,1 ,0)

  u_K = jnp.fft.ifftn(u_hat*mask_K, axes = (1,2,3))

  mask_Q = np.where((sqrt_k2_whole >= Q_min),1 ,0)*np.where((sqrt_k2_whole <= Q_max) ,1 ,0)

  u_Q = u_hat*mask_Q

  u_tensor = jnp.fft.ifftn(jnp.einsum('ijkl,mjkl -> imjkl',1j*k_whole,u_Q),axes = (2,3,4))

  transfer = jnp.sum(u_K*jnp.einsum('ijkl , imjkl -> mjkl', u,u_tensor))

  return transfer

@jit
def compute_energy_flux(u_hat, K_cut, k_whole = k_whole, sqrt_k2_whole = sqrt_k2_whole):
    u = jnp.fft.irfftn(u_hat, axes=(1, 2, 3))  # shape: (3, Nx, Ny, Nz)

    u_hat_full = jnp.fft.fftn(u, axes=(1, 2, 3))  # shape: (3, Nx, Ny, Nz)

    grad_u_hat = 1j * k_whole[:, None] * u_hat_full[None, :, ...]  # shape: (3,3,Nx,Ny,Nz)
    grad_u = jnp.fft.ifftn(grad_u_hat, axes=(2, 3, 4))  # shape: (3,3,Nx,Ny,Nz)

    adv_term = jnp.einsum('i...,ij...->j...', u, grad_u)

    mask_lp = (sqrt_k2_whole <= K_cut).astype(u_hat.dtype)

    u_lp = jnp.fft.ifftn(u_hat_full * mask_lp, axes=(1, 2, 3))  # shape: (3,Nx,Ny,Nz)

    flux = jnp.sum(jnp.real(u_lp * adv_term))

    return flux

def shell_by_shell_fluxes(u_hat, shells= shells , sqrt_k2= sqrt_k2, sqrt_k2_whole= sqrt_k2_whole, k_whole= k_whole):

    u = jnp.fft.irfftn(u_hat, axes=(1, 2, 3))
    u_hat = jnp.fft.fftn(u, axes=(1, 2, 3))

    dumm_field = 0

    for i in range(1, len(shells)):
        # Create binary mask
        mask_K = jnp.logical_and(
            sqrt_k2_whole >= shells[i - 1],
            sqrt_k2_whole <= shells[i]
        )*1.0

        # Apply mask
        u_K = u_hat * mask_K

        # Compute flux contribution and accumulate
        flux_term = jnp.fft.ifftn(jnp.sum(u_K * 1j * k_whole, axis=0), axes=(0, 1, 2))
        dumm_field += flux_term

    return dumm_field

a = shell_by_shell_fluxes(U_hat)
plt.imshow(a[1].real, cmap = 'inferno')
plt.colorbar()

def compute_flux_spectrum(u_hat, k_bins, k_whole = k_whole , sqrt_k2_whole = sqrt_k2_whole):
    return jnp.array([compute_energy_flux(u_hat, K, k_whole, sqrt_k2_whole) for K in k_bins])

PI_K = compute_flux_spectrum(U_hat , kvals)

plt.plot(kvals[:14],PI_K[:14]/PI_K[9])
plt.axvline(11)

np.savez_compressed('u_RAJ', U = U_real )

